<!DOCTYPE html><html lang="en" data-astro-cid-37fxchfa> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.1.1"><title>salnad - salnad</title><link rel="stylesheet" href="/_astro/index.R9HrAklZ.css">
<style>@keyframes gradient{0%{background-position:0% 0%}50%{background-position:100% 100%}to{background-position:0% 0%}}.fun-text[data-astro-cid-j7pv25f6]:hover{background:linear-gradient(45deg,red,orange,#ff0,green,#00f,indigo,violet);background-size:150% 150%;background-clip:text;-webkit-background-clip:text;color:transparent;animation:gradient 3s linear infinite}
</style></head> <body class="bg-black min-h-screen flex flex-col items-center justify-center font-['Comic_Sans_Mono',_monospace] px-[10%] py-[5%]" data-astro-cid-37fxchfa> <main class="text-center w-full md:w-1/2 mx-auto" data-astro-cid-37fxchfa> <div class="text-left w-full" data-astro-cid-j7pv25f6><h1 class="text-5xl font-bold text-white mb-4" data-astro-cid-j7pv25f6><span class="block md:hidden" data-astro-cid-j7pv25f6>salil nadkarni</span><span class="hidden md:inline" data-astro-cid-j7pv25f6><span id="matrix-scramble" class="cursor-pointer">salil nadkarni</span> <script>(function(){const startText = "salil nadkarni";
const endText = "salnad";

  // Matrix scramble animation
  document.addEventListener("DOMContentLoaded", () => {
    const element = document.getElementById("matrix-scramble");
    if (!element) return;
    
    // Characters to use for scrambling effect
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
    
    // Duration of the animation in milliseconds
    const duration = 2000;
    // How often to update the text during animation (in milliseconds)
    const interval = 50;
    
    let isAnimating = false;
    let currentDisplayText = startText;
    let hasInitialAnimationRun = false;
    
    // Function to animate from one text to another
    const animateText = (from, to) => {
      if (isAnimating) return;
      isAnimating = true;
      
      const startTime = Date.now();
      const iterations = Math.floor(duration / interval);
      let currentIteration = 0;
      
      const animationInterval = setInterval(() => {
        currentIteration++;
        const progress = currentIteration / iterations;
        
        // Generate the current text based on progress
        let currentText = "";
        
        // Calculate the current target length based on progress
        const fromLength = from.length;
        const toLength = to.length;
        const currentTargetLength = Math.round(fromLength + (toLength - fromLength) * progress);
        
        // For each position up to the maximum length of both strings
        const maxLength = Math.max(fromLength, toLength);
        
        for (let i = 0; i < maxLength; i++) {
          // If this position is beyond our current target length, skip it
          if (i >= currentTargetLength) {
            continue;
          }
          
          // If this character position exists in both strings
          if (i < fromLength && i < toLength) {
            // Determine if we should show the final character based on progress
            const charProgress = progress * 1.5; // Slightly accelerate character transitions
            const charThreshold = i / maxLength;
            
            if (charProgress > charThreshold) {
              // Gradually transition to the target character
              if (Math.random() > (1 - charProgress + charThreshold)) {
                currentText += to[i];
              } else {
                currentText += chars[Math.floor(Math.random() * chars.length)];
              }
            } else {
              // Keep the original character
              currentText += from[i];
            }
          } 
          // If this position only exists in the target string (we're adding characters)
          else if (i >= fromLength && i < toLength) {
            // Only start showing these characters once we're partway through the animation
            const appearThreshold = 0.3 + (i - fromLength) / (toLength - fromLength) * 0.5;
            
            if (progress > appearThreshold) {
              if (progress > 0.9 && Math.random() > 0.5) {
                currentText += to[i];
              } else {
                currentText += chars[Math.floor(Math.random() * chars.length)];
              }
            }
          }
          // If this position only exists in the source string (we're removing characters)
          else if (i < fromLength && i >= toLength) {
            // Gradually remove characters as progress increases
            const removeThreshold = 0.2 + (i / fromLength) * 0.6;
            
            if (progress < removeThreshold) {
              currentText += from[i];
            }
          }
        }
        
        // If we're at the end of the animation, show the final text
        if (currentIteration >= iterations) {
          clearInterval(animationInterval);
          element.textContent = to;
          isAnimating = false;
          currentDisplayText = to;
        } else {
          element.textContent = currentText;
        }
      }, interval);
    };
    
    // Function to handle hover events
    const handleHover = () => {
      if (hasInitialAnimationRun) {
        // Toggle between startText and endText
        if (currentDisplayText === startText) {
          animateText(startText, endText);
        } else {
          animateText(endText, startText);
        }
      }
    };
    
    // Initial animation (startText to endText)
    const startInitialAnimation = () => {
      animateText(startText, endText);
      hasInitialAnimationRun = true;
    };
    
    // Start animation when element is hovered
    element.addEventListener("mouseenter", () => {
      if (!hasInitialAnimationRun) {
        startInitialAnimation();
      } else {
        handleHover();
      }
    });
    
    // Optional: Start initial animation when element is in view
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          setTimeout(startInitialAnimation, 500); // Delay to make it noticeable after page load
          observer.disconnect();
        }
      });
    });
    
    observer.observe(element);
  });
})();</script></span></h1><h3 class="text-xl text-white mb-8 italic" data-astro-cid-j7pv25f6>software engineer @ slack, university of michigan alum</h3><h2 class="text-xl text-white mb-8 font-bold tracking-wide" data-astro-cid-j7pv25f6>interested in education, creativity, ai, and <span class="fun-text" data-astro-cid-j7pv25f6>having fun</span></h2><blockquote class="text-white text-lg mb-12 border-l-4 pl-4 italic" data-astro-cid-j7pv25f6>
welcome to my site 👋🏾 <br data-astro-cid-j7pv25f6>
a lil' digital garden 🌱 <br data-astro-cid-j7pv25f6>
thanks for stopping by ✨
</blockquote><p class="text-white text-lg mb-12" data-astro-cid-j7pv25f6>explore some
<a href="/things" class="text-white hover:text-gray-300 transition-colors underline decoration-dotted hover:decoration-solid" data-astro-cid-j7pv25f6>things 🔨</a> i've made, 
            a <a href="/trail" class="text-white hover:text-gray-300 transition-colors underline decoration-dotted hover:decoration-solid" data-astro-cid-j7pv25f6>trail 🔎</a> of things that have caught my attention,
            and my <a href="/thoughts" class="text-white hover:text-gray-300 transition-colors underline decoration-dotted hover:decoration-solid" data-astro-cid-j7pv25f6>thoughts 🧠</a>.</p></div> </main> <footer> <hr class="border-gray-700 my-8"> <div class="flex gap-6 justify-center"> <a target="_blank" class="text-white hover:text-gray-300 transition-colors" href="https://github.com/salnad">github</a><a target="_blank" class="text-white hover:text-gray-300 transition-colors" href="https://www.linkedin.com/in/salnad">linkedin</a><a target="_blank" class="text-white hover:text-gray-300 transition-colors" href="mailto:salnad02@gmail.com">email</a><a target="_blank" class="text-white hover:text-gray-300 transition-colors" href="/files/salil-nadkarni-resume-aug-2024.pdf">resume</a> </div> </footer> </body></html>